{"/contributing":{"title":"Contributing","data":{"":"First of all, thank you for your interest in contributing to the Atros project. It's nice to see you among us.The best way to find what to contribute in the project is to use it personally for your different needs. To do that, install Atros in your system. You can find the Getting Started guide in the README file, follow these steps to start contributing.","about-the-repositories#About the Repositories":"The main repository is the one you're inside currently, and it's a single binary Rust application that follows Rust's module structure. Therefore, it's simple to work on.There are two more repositories to know about: config-template, which is the main configuration template that you clone to your .config/ directory when you run atros init, and in this template repository, we have config-prerequisites as a git submodule. The reason for having a separate repo is to be able to update Atros easily without wiping users' defined steps. Since the type definitions in that repository might get updated at some point, when we implement an upgrade CLI command in this tool, we want to upgrade not only the binary itself but also the prerequisites folder (which is .atros in the ~/.config/atros/ folder)","how-to-contribute-to-the-main-repository#How to Contribute to the Main Repository":"","fork-this-repo#Fork This Repo":"You can fork this repo by clicking the fork button in the top right corner of this page.\n# Clone on your local machine\ngit --recursive clone git@github.com:your-username/atros.git # --recursive is for examples/ folder\n\n# Navigate to the project directory\ncd atros/\n\n# Create a new branch\ngit checkout -b cool-branch\nThen, you're ready to hack!\ncargo run               # Will print help text\ncargo run -- <command>  # Will run the command you provide: init, run, help, etc.","how-to-contribute-to-prerequisites#How to Contribute to Prerequisites":"If you want to change type definitions or add new ones, this will be helpful.","fork-the-repo#Fork the Repo":"Go to config-prerequisites repository, and fork it.","replace-the-default-prerequisites-with-yours#Replace the default prerequisites with yours":"# Go to your config\ncd ~/.config/atros\n\n# Remove the default prerequisites folder\nrm -rf .atros\n\n# Clone your forked repo\ngit clone git@github.com:your-username/config-prerequisites.git .atros\n\n# Navigate to the repo\ncd .atros\n\n# Create a new branch\ngit checkout -b cool-types\nAnd again, you're ready to hack!","commit-convention#Commit Convention":"Before you create a Pull Request, please check whether your commits comply with the commit conventions used in this repository.When you create a commit, we kindly ask you to follow the convention¬†category(module or subject): message¬†in your commit messages while using one of the following categories:\nfeat / feature: All changes that introduce completely new code or new features\nfix: Changes that fix a bug (ideally you will additionally reference an issue if present)\nrefactor: Any code-related change that is not a fix or a feature\ndocs: Changing existing or creating new documentation (i.e. README, type documentation)\nbuild: All changes regarding the build of the software, changes to dependencies, or the addition of new dependencies\ntest: All changes regarding tests (adding new tests or changing existing ones)\nci: All changes regarding the configuration of continuous integration (i.e. GitHub Actions, CI system)\nchore: All changes to the repository that do not fit into any of the above categories\n\nExamples:\nfeat(testing): get user input to skip succeeded tests\nfeat: bash file support for writing tests\nrefactor(testing): change in cache's JSON structure to make it more comprehensive\n\nIf you are interested in the detailed specifications, you can visit¬†https://www.conventionalcommits.org/"}},"/":{"title":"Introduction","data":{"":"Atros is an automation tool that's focused on the developers, instead of software projects developed by them.","-features#‚ú® Features":"üöÄ Blazingly Fast: I'm not sure how fast it is, but it's written in 100% Rust btw üòâ\n‚úÖ Easy to Write Tasks: Write your tasks in Typescript easily with in-editor documentation and conditional types\nüíª Define Cross-platform Tasks: Specify the platform your task will work\nüì• Cross-platform Package Management: Don't worry about installing packages for every system. Just define install tasks, and give a package list to install them\nüíæ Caching: Atros caches your execution results. So you don't have to worry about running a succeeded task twice. This is useful when you have succeeded and failed tasks in a step at the same time\nü§ù Works With All Javascript Runtimes: Node, Bun, Deno. Doesn't matter, all you guys are welcome. Just have at least one of them installed in your system.","-upcoming-features#‚åõ Upcoming Features":"üîë Store Sensitive Keys Easily: Encrypt, decrypt, and use your keys easily in your tasks\nüß™ Test Your Tasks: Write tests for your tasks. Tests for install tasks are defined by default, and cross-platform. Run tests to see if your system has everything up and going, or tasks with only failed tests.\nRun&Test Without Installing Files via Git: Because sometimes you just wonder if you have a system that's capable of doing things that some guy on the internet's is.\nü™ü Windows Support: Not promised for a long period of time. But seems like it's the point that the project is headed to","-getting-started#üí´ Getting Started":"# Install Atros binary\ncargo install atros\n\n# Initialize your configuration automatically in ~/.config/atros\natros init\nTo learn more about Atros and how to configure your first steps, check out the getting started section","-why-use-atros#‚ùì Why Use Atros?":"Because Atros is a pure project, it tries to solve only one kind of problem: The kind that people might encounter in a major end-user system/distro, like automating their development environment in a cross-platform way. This laser-focus approach leads to a simple-to-use project.Before Atros, choosing an automation tool was a two-pointed blade. On one side we have the good-old Bash script, which is too simple to provide defining cross-platform commands, parameters, and packages to install. The other side is all other tools, like Ansible, Chef, and Nix. Which are excellent to use, has no technical issues, and has been there for many years. But their view of life differs. They either focus on software projects or introduce overhead.Atros doesn't push you to install a new package manager, nor does it try to teach you a new build system. It lets you write your shell commands in bash and runs your package installation commands with the default package manager of your system. So, Atros is not a whole new tool you need to search through docs for hours to learn. It's more like a layer between you and your shell, that provides features like defining platform-specific commands, parameters, and packages to install.","-current-status#üìä Current Status":"Atros is still in its early days, so issues are to be expected. Also, v1.0 has not been released yet, therefore incompatibilities with the new versions should be expected for some functionalities. But Atros is available for use in task automation today, and no big breaking changes are expected for the main functionalities like task definitions. Still, compatibility is not promised ‚ò†Ô∏è","-contributing#üí¨ Contributing":"We need all of you to make Atros an amazing tool! If you're interested in the idea of the project, please take a look at the contributing section."}},"/getting-started/specifying-system":{"title":"Specifying System","data":{"":"Like we said in the previous section: You can define a system to anything in Atros; to tasks, packages, and parameters. Let's see examples for each of them in this section.","-tasks-with-a-system#üìù Tasks With a System":"You can define a system for a whole task to run it only in the specified system.\n[\n{\ntype: \"shell\",\ncmd: \"echo 'I use Arch btw'\",\nsystem: \"arch\",\n},\n];\nSimple, isn't it? Let's look at another example of installing packages.\n[\n{\ntype: \"install\",\npackages: [\"neovim\", \"firefox\"], // Cross-platform packages\n},\n{\ntype: \"install\",\npackages: [\"build-essentials\"], // A debian package\nsystem: \"debian\",\n},\n];\nThis looks great, right? No, it does not. Trust me.","-packages-with-a-system#üì¶ Packages With a System":"Writing a whole new task to install a package in a different system is verbose and not up to Pollos Atros standards. Instead, you can define a system for packages too! Let's see the same example without the verbosity.\n[\n{\ntype: \"install\",\npackages: [\n\"neovim\",\n\"firefox\",\n{\nsystem: \"debian\",\nlist: [\"build-essential\"],\n},\n],\n},\n];\nThis is much simpler, especially when you're automating your real environment. But what about installing packages that require different parameters in different systems? Like, installing the Neovide package requires a --cask parameter. Again, defining a new task to install a package for each different system is not up to our standards.","Ô∏è-parameters-with-a-system#‚öôÔ∏è Parameters With a System":"Let's see how we would define a system for a parameter. We'll use a verbose way here, and they will fix it to use a single task.\n[\n{\ntype: \"install\",\npackages: [\"neovim\", \"firefox\"],\n},\n{\ntype: \"install\",\npackages: [\"neovide\"],\nparameters: [\n{\nsystem: \"mac\",\nlist: [\"--cask\"], // Use --cask parameter in MacOS\n},\n],\n// This is the exact same way the pre-defined cask parameter is implemented\n// So, you could just use this to get the same result:\n// parameters: [cask]\n},\n];\nAs the comment lines state, this is an already defined parameter. However, we'll continue using it to demonstrate. After you learn, you can use any parameter you want with a system.Here we accomplish what we want: A system-specific task. But it took a whole new task to do it, where we could simply define a parameter inside the packages field of one single task. Let's see.\n[\n{\ntype: \"install\",\npackages: [\n\"neovim\",\n\"firefox\",\n{\nlist: [\"neovide\"],\nparams: [\n{\nlist: [\"--cask\"],\nsystem: \"mac\",\n},\n],\n},\n],\n},\n];\nJust like that!","-youre-more-than-ready#üöÄ You're More Than Ready":"With knowing this too, you're more than ready to define your tasks and execute them with Atros. So let's try out!If you encounter any problem, the community will kindly help. Don't hesitate to ask in Github."}},"/getting-started/define-tasks":{"title":"Define Tasks","data":{"":"We have two different types of tasks: shell and install. Both use a type field to define their type, and the other fields depend on the type of your task. Let's see how to define both of these kinds of tasks in action!","-shell-task#üìü Shell Task":"Shell tasks are the most primal ones. They only require a cmd field, and when you run that task, Atros tries to execute the value of this field you provided using the sh command.\n{\ntype: \"shell\",\ncmd: \"echo 'Hey, welcome to Atros'\",\n}\nThis task will run echo 'Hey, welcome to Atros' on your system using sh","-install-task#üì• Install Task":"On the other hand, while still being simple to define, install tasks have more functionality than a simple task. It needs to find your system's default package manager and check if you have a special system or parameter definition for any package. We'll talk about all of these functionalities, but let's start easy. An install task has 3 fields: type, packages, and parameters (parameters are optional) With this in mind, we can define a simple task that installs Neovim.\n{\ntype: \"install\",\npackages: [\"neovim\"],\nparams: [], // optional\n}\nAnd done! Now running atros run will install Neovim in your system. You might ask though, why should I use an install task when I already have shell? The answer is out-of-the-box cross-platform support. As we mentioned above, an install task finds your system before it gets executed, so in MacOS, this task gets executed as brew install neovim, while in Debian the same task will become apt install neovim","package-manager-parameters#Package Manager Parameters":"Of course, this is not the only advantage of an install task. Giving a parameter to package managers gets much easier with install tasks, since they have a params field that supports system-specific parameters, we'll later talk about system specificity.\n{\ntype: \"install\",\npackages: [\"neovide\"],\n// Remember the pre-defined parameters we imported earlier?\n// Changed neovim to neovide for demonstrating cask\nparams: [cask]\n}","all-pre-defined-parameters#All Pre-Defined Parameters":"apt_get\nSystem: Debian Based\nWhat it Does: Runs apt-get instead of apt\n\n\ncask\nSystem: MacOS\nWhat it Does: Adds --cask parameter\n\n\nyay\nSystem: Arch Based\nWhat it Does: Runs yay instead of pacman","-specifying-system#üíª Specifying System":"But how do these parameters work system-specific? Well, the truth is parameters are not the only thing you can define a system to. In Atros, you can specify a system for each task, package, and of course, parameter. Using this, we can change the outcome of our tasks for each system that you can install and use Atros.We'll talk about this in-depth in the next chapter."}},"/getting-started/first-steps":{"title":"First Steps Into Atros","data":{"":"Let's start by setting up your first Atros configuration. It has a flawless setup process:","Ô∏è-requirements#üóÇÔ∏è Requirements":"JavaScript Runtime: You need to have a JavaScript runtime installed in your system to parse steps. Atros is compatible with any runtime out there: NodeJS, Bun, or Deno\nCargo: Atros is available only as a Cargo Crate at the moment. It'll later be available in other formats, but now you must have cargo available in your system\nSystem: You can run Atros in MacOS and Linux distributions based on Debian, Arch or Fedora","-install-atros-and-initialize#üì• Install Atros and Initialize":"cargo install atros\n\natros init\nThe command atros init creates the ~/.config/atros/ folder, initializes the required type definitions, and most importantly, creates your first step in steps/.","-basics-of-a-step-file#üëü Basics of a Step File":"","-file-structure#üìÇ File Structure":"To define a new step, create a file in atros/steps/. It's recommended to create your file in 01-step-name.ts format, start by using a two-digit number to guarantee that Atros will run them in the order you intended to.Folders and extentions other than .ts are not valid at the moment, they'll be passed or will cause errors.","Ô∏è-defining-a-step#‚úèÔ∏è Defining a Step":"Let's define the simplest task we can to learn what a usual step file looks like. Then we'll break it down in more detail.\n// 01-initial-step.ts\n\nimport { AtrosStep, PredefinedParameters } from \"../.atros\";\n\nconst { apt_get, cask, yay } = PredefinedParameters;\n\nconst step: AtrosStep = {\ntitle: \"Step Title\",\ndescription: \"The first task we defined (optional field)\",\ntasks: [],\n};\n\nexport default step;","1-import-requirements#1. Import Requirements":"Each step file starts similarly by importing 2 things:\nAtrosStep, the interface defined for our steps\nPredefinedParameters, a list of frequently encountered parameters. We'll later use them inside our install tasks to give parameters to package managers\n\nThen we spread pre-defined parameters to use them easily later.","2-define-an-empty-step#2. Define an Empty Step":"A step type has two required fields: title and tasks, also an optional field called description. After the definition, we export it with default keyword to point what will Atros parse in this file when running atros run. While we speak of running it, you can try to run atros run to see how beautifuly it succeeds!.This is the simplest step that you can define without getting any error. However, nothing happens in your system after you run it, no installed packages, no executed command. Because we didn't define any task to run inside our step.In the next chapter, we'll dive into tasks and execute our first command with Atros."}}}